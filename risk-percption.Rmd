---
title: "risk-perception"
author: "Nick Gauthier"
date: "9/18/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lpSolve)

#library(zoo)
```

Start with a population of agents with the same subjective beliefs about drought risk.

```{r}
agents <- tibble(id = 1:100, 
                 alpha = 1.5,
                 beta = 1.5,
                 risk = alpha / (alpha + beta))
```

```{r}
agents
```


And payoffs for different crop types in different years.
```{r}
wheat_dry <- 0
wheat_wet <- 1.6
barley_dry <- 0.93
barley_wet <- 1.18
```

The expected yield is thus calculated as.
```{r}
expected_utility <- function(risk) {
  risk * (wheat_dry + barley_dry) + (1 - risk) * (wheat_wet + barley_wet) 
}
```

```{r}
expected_utility(0.2) # assuming a drought risk of 0.2
```

Given these payoffs, what's the point of indifference between the two crop types?

```{r, echo = FALSE}
plt_dat <- tibble(risk = seq(0, 1, .1),
       barley_exp = risk * barley_dry + (1 - risk) * barley_wet,
      wheat_exp = risk * wheat_dry + (1 - risk) * wheat_wet) %>%
  gather(type, utility, barley_exp:wheat_exp)
```

The pure maximin strategy is to plant barley:
```{r}
max(wheat_dry, barley_dry)
```


```{r, echo = FALSE}
indiff <- tibble(risk = (barley_wet - wheat_wet) / (wheat_dry - wheat_wet - barley_dry + barley_wet),
                 utility = risk * wheat_dry + (1 - risk) * wheat_wet)

plt_dat %>%
  ggplot(aes(risk, utility)) +
  geom_hline(yintercept = indiff$utility, linetype = 2)+
  geom_vline(xintercept = indiff$risk, linetype = 2) +
  geom_line(aes(color = type), size = 1.2) +
  geom_point(data = indiff, color = 'black', size = 3) +
  geom_text(data = indiff, label = '(0.3, 1.1)', nudge_x = 0.1, nudge_y = 0.1) +
  theme_classic()
```

The maximin strategy here is to plant barley all the time, but this entails a huge opportunity cost over planting wheat or a mix of the two. So the intersection point of the next plot is the mixed strategy equilbrium(indifference point) in a risk-free environment

```{r, echo = FALSE}
nash_eq <- tibble(wheat_prop = round((barley_wet - barley_dry) / (wheat_dry + barley_wet - (wheat_wet + barley_dry)), 2),
                  utility = round(wheat_wet * wheat_prop + barley_wet * (1 - wheat_prop), 2))

tibble(wheat_prop = seq(0, 1, .1),
       dry_exp = wheat_prop * wheat_dry + (1 - wheat_prop) * barley_dry,
      wet_exp = wheat_prop * wheat_wet + (1 - wheat_prop) * barley_wet) %>%
  gather(type, utility, dry_exp:wet_exp) %>%
  ggplot(aes(wheat_prop, utility)) +
  geom_hline(yintercept = nash_eq$utility, linetype = 2)+
  geom_vline(xintercept = nash_eq$wheat_prop, linetype = 2) +
  geom_line(aes(color = type), size = 1.2) +
  geom_point(data = nash_eq, color = 'black', size = 3) +
  geom_text(data = nash_eq, 
            label = paste0('(', nash_eq$wheat_prop, ', ', nash_eq$utility, ')'),
            nudge_x = 0.1, nudge_y = 0.05) +
  theme_classic()
```

```{r}
# farmer's ne
pmax(0, round((barley_wet - barley_dry) / (wheat_dry + barley_wet - (wheat_wet + barley_dry)), 2))

#nature's ne
round((barley_wet - wheat_wet) / (wheat_dry + barley_wet - (wheat_wet + barley_dry)), 2)
```

0.3111 is also the indifference point for the farmer with respect to crops. That is, if we imagine nature playing strategically, a drought would occur with probability 0.31111 because that would make nature indifferent to whether the farmer planted wheat or barley.

when you sample from the expected value, use that to choose a strategy. but if you sample lots, use that to create a mixed streateg

And the subjective expected yields for the agents are thus.
```{r}
agents %>%
  mutate(risk = runif(n())) %>%
  mutate(yield_exp = expected_utility(risk),
         barley_exp = risk * barley_dry + (1 - risk) * barley_wet,
         wheat_exp = risk * wheat_dry + (1 - risk) * wheat_wet,
         favorite = case_when(barley_exp == wheat_exp ~ 'either',
                              barley_exp > wheat_exp ~ 'barley',
                              barley_exp < wheat_exp ~ 'wheat')) 
```

```{r}
calc_ratio <- function(risk) {
  pmax(0, (risk * barley_dry + (risk - 1) * barley_wet) / (risk * (barley_dry - wheat_dry) + wheat_wet * -1 * risk + wheat_wet + barley_wet * (risk - 1)))
}
```

Simulate a time series with varying drought frequency.
```{r}
droughts <- c((runif(25) < .1),(runif(25) < .5), runif(50) < .1)
```

Allow the agents to learn the drought risk over time.
```{r}
learn <- function(agents, event) {
  agents %>%
    mutate(alpha = event + alpha,
           beta = beta + 1 - event,
           mu = alpha / (alpha + beta),
           risk = map2_dbl(alpha, beta, ~rbeta(1, .x, .y)))
}
```


Run an experiment.
```{r}
simulation <- accumulate(droughts, ~learn(.x, .y), .init = agents) %>% 
  bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time)) %>%
  filter(time != 1)
```


```{r}
ggplot(simulation, aes(time, risk)) +
  geom_point(alpha = .1) +
  geom_hline(yintercept = indiff$risk, color = 'red', linetype = 2) +
  theme_classic()
```

Think about the importance of the population's age structure, becuase that's going to impact the collective memory of drought.

```{r}
knitr::knit_exit()
```



maximax
```{r}
risk <- 0.9
wheat_exp <- wheat_wet * (1 - risk) + wheat_dry * risk
barley_exp <- barley_wet * (1 - risk) + barley_dry * risk
obj.fun <- c(wheat_exp, barley_exp)

constr=matrix(c(1,1,1,0,0,1, wheat_exp, barley_exp),ncol = 2, byrow = TRUE) #Loading the constraints
constr.dir=c("=",">=",">=", ">=")
constr.rhs=c(1,0,0, .5)

mod=lp("min",obj.fun,constr,constr.dir,constr.rhs) #Using lp() to solve our problem
mod$solution
```

```{r}
calc_payoff <- function(x, drought) {
  if (drought == 'TRUE') wheat_yield <- wheat_dry; barley_yield <- barley_dry
  if (drought == 'FALSE') wheat_yield <- wheat_wet; barley_yield <- barley_wet
  
  x %>%
    mutate(yield = wheat_yield * wheat_prop + barley_yield * (1 - wheat_prop))
}

update_prop <- function(x, aspiration) {
  x %>%
    mutate(new_prop = round(runif(n()), 2),
           wheat_prop = if_else(yield > aspiration, wheat_prop, new_prop)) %>%
    select(-new_prop)
}

test3 <- tibble(agent = 1:1000) %>%
  mutate(wheat_prop = round(runif(n()), 2)) %>%
  calc_payoff(drought = TRUE)
test3 %>% update_prop(aspiration = .6)

accumulate((runif(25) < .3), ~calc_payoff(.x, drought = .y) %>% update_prop(aspiration = .5), .init = test3) %>% bind_rows(.id = 'time') %>% ggplot(aes(as.numeric(time), yield, group = agent)) + geom_line(alpha = .2)

```

```{r}
library(ggridges)
accumulate((runif(25) < .2), ~calc_payoff(.x, drought = .y) %>% update_prop(aspiration = .6), .init = test3) %>% bind_rows(.id = 'time') %>% ggplot(aes(wheat_prop, y = as.numeric(time), group = as.numeric(time))) +
  geom_density_ridges() +
  theme_minimal()
```


So at between 3 in 10 and 4 in 10 risk of drought, a maximizer will switchfrom wheat to barley.


```{r}
test_dat <- expand_grid(wheat_prop = (0:10)/10,
       risk = seq(.1, .9, 0.1)) %>%
  mutate(util_wet = (1 - risk) * (wheat_wet * wheat_prop + barley_wet * (1 - wheat_prop)),
         util_dry = risk * (wheat_dry * wheat_prop + barley_dry * (1 - wheat_prop)),
         util_wheat = wheat_prop * (wheat_wet * (1 - risk) + wheat_dry *  risk),
         util_barley = (1 - wheat_prop) * (barley_wet* (1 - risk) + barley_dry * risk),
         payoff_exp = util_dry + util_wet,
         payoff_max = pmax(util_wheat, util_barley))
```

```{r}
nash_eq2 <- tibble(risk = seq(0.1, 0.9, 0.1),
                   wheat_prop = pmax(round(((1 - risk) * barley_wet - risk * barley_dry) / (risk * wheat_dry + (1 - risk) * barley_wet - ((1 - risk) * wheat_wet + risk * barley_dry)), 2), 0),
                  utility = round(risk * wheat_dry * wheat_prop + risk * barley_dry * (1 - wheat_prop), 2))

test_dat %>%
  select(-(util_wheat:util_barley)) %>%
  gather(type, utility, c(util_dry, util_wet)) %>%
    ggplot(aes(wheat_prop, utility)) + 
  geom_line(aes(color = type)) + 
  facet_wrap(~risk) + 
  geom_hline(data = nash_eq2, aes(yintercept = utility), alpha = .3, linetype = 2) + 
  geom_vline(data = nash_eq2, aes(xintercept = wheat_prop), alpha = 0.3,linetype = 2) +
  geom_point(data = nash_eq2) +
  theme_classic()
```


```{r}
test_dat %>%
  select(-(util_dry:util_wet)) %>%
  gather(type, util, util_wheat:util_barley) %>%
  ggplot(aes(wheat_prop, util, color = type)) + 
  geom_line() + 
  facet_wrap(~risk) + 
  geom_vline(xintercept = nash_eq$wheat_prop)
```

Here we see that the mixed strategy that maximizes expected utility is always a pure strategy.
```{r}
test_dat %>%
  gather(type, utility, payoff_exp:payoff_max) %>%
  ggplot(aes(wheat_prop, utility)) + 
  geom_line(aes(color = type)) +
  facet_wrap(~risk)
```

So both the Wald and Savage regret criteria tell us to choose barley all the time.

If we're using the empirical frequency distirubtion of nature's moves, then we are playing a fictitious game. The strategy of planting the crop with the highest expected yield, given the frequency distribution of nature is known, will only work when nature is stationary.

We could think of other algorithms that would minimize the cumulative or average regret of a player over many years in a situation with nonstationary rainfall, but we have to remain within cognitive limits.

```{r}
# this is for nature
calcNE <- function(risk){
  (118 - 25 * risk) / (278 - 185 * risk)
}

plot(0:10, calcNE((0:10)/10))
```




so we're imagining a yield of 1 for barley and 2 for wheat, with equal prportions of each. then in the next time step we'd revise the proportion to take away .25
```{r}
reallocate <- function(wheat_prop, risk) {
  wheat_prop + 1 * (1.18 * (1 - wheat_prop) - 1.6 * wheat_prop) * wheat_prop * (1 - wheat_prop)
}

accumulate(1:10, ~reallocate(.x), .init = .4) %>% plot

# so this works as long as you're between 0 and 1
```


```{r}

prior <- function(m,n){
a = n * m
b = n * (1 - m)
dom <- seq(0,1,0.005)
val <- dbeta(dom,a,b)
return(data.frame('x'=dom, 'y'=val))
}

prior(.5, 2) %>% plot
```

```{r}
likelihood <- function(N,Y){
a <- Y + 1
b <- N - Y + 1
dom <- seq(0,1,0.005)
val <- dbeta(dom,a,b)
return(data.frame('x'=dom, 'y'=val))
}

likelihood(1, 1)%>% plot
```

```{r}
posterior <- function(m,n,N,Y){
a <- Y + (n*m) -1
b <- N - Y + (n*(1-m)) - 1
dom <- seq(0,1,0.005)
val <- dbeta(dom,a,b)
return(data.frame('x'=dom, 'y'=val))
}


-1
1 - 0 - 1

dbeta(seq(0,1,0.005), -1, 0)
prior(.5, 2) %>% plot
posterior(.5, 3, 1, 1) %>% plot
```


so now we get the same yields, but the proportions are different
```{r}
(1 *  0.625 - 2 * .375) * .375 * .625
```

```{r}
1- .375
```


```{r}
-1 * 0.0625 * (1 - 0.0625)
```



```{r}
yield_max_barley <- 2500
yield_max_wheat <- 3500
kcal_barley <- 3000
kcal_wheat <- 3540

calc_yield <- function(rainfall, crop = 'wheat') {
  if (crop == 'wheat') {
    yield <- yield_max_wheat * kcal_wheat * pmax(0, 0.51 * log(rainfall) + 1.03)  # annual rainfall impact on yields
  }
  
  if(crop == 'barley') {
    yield <- yield_max_barley * kcal_barley * pmax(0, 0.48 * log(rainfall) + 1.51) 
  }
  
  return(yield)
}


tibble(rainfall = (0:200) / 100,
       barley = calc_yield(rainfall, 'barley'),
       wheat = calc_yield(rainfall, 'wheat')) %>%
  gather(crop, yield, barley:wheat) %>%
  ggplot(aes(rainfall, yield, color = crop)) + 
  geom_line() +
  geom_hline(yintercept = yield_max_wheat * kcal_wheat) +
  geom_hline(yintercept = yield_max_barley * kcal_barley) +
  geom_hline(yintercept = 1016525* 5, color ='red') +
  geom_vline(xintercept = 0.3)
```

How do we define the "drought year" cutoff? Below 300mm there isn't enough wheat growing in a hectare to feed a family of 5, which seems appropriate.
```{r}
test <- tibble(time = 1:100,
       rain = rnorm(100, mean = 1, sd = 1) %>% pmax(0),
       yield = calc_yield(rain))

ggplot(test, aes(time, yield)) + geom_point() + geom_hline(yintercept = 1016525)

test %>%
  mutate(drought = if_else(yield < 5e+6, TRUE, FALSE))%>%
  filter(drought == TRUE)
```


```{r}
# generate some forgetting curves
forgetting_curves <- tibble(x = c(.01, .1, 1, 0)) %>%
  mutate(memory = map(x, ~exp(-1 * . *1:50))) %>%
  unnest(cols= c(memory)) %>%
  group_by(x) %>%
  mutate(time = 1:n())

ggplot(forgetting_curves, aes(time, memory)) +
  geom_line(aes(color = as.factor(x)), size = 1.2) +
  labs(title = 'Forgetting curves', x = 'Years', y = 'Relative memory strength\n') +
  scale_color_viridis_d(name = 'Decay rate') +
  theme_classic()
```

```{r}
farm <- function(households){
  households %>%
    mutate(yield = climatic_yield, #* n_inhabitants ^ labor_elasticity,
           yield_memory = yield, #map2(yield_memory, yield, remember),
           harvest = land * yield * .5 - land * sowing_rate) #%>%  # *.5 is for fallow
  #select(-yield)
}


remember <- function(yield_memory, yield){
  # rnorm(1, yield, yield * 0.0333) %>%  #memory is fuzzy
  append(yield_memory[-length(yield_memory)], yield, after = 0) # remove the last entry in the vector and add new yield to the begining
}


#Agents use the peak-end rule when accessing memory.
peak_end <- function(x){
  map_dbl(x, ~mean(c(.x[1], min(.x))))
}

```




```{r}
obs.na <- read.csv('salihli_p.csv')[10:620, 5]  / 10  # raw data in mm*10. subset time series as water years (i.e. first observation is october, last is september)

get.winter <- function(x){seq(0, length(x) - 12, 12) %>%
    sapply(function(y) y + 1:6) %>%
    as.numeric %>% extract(x, .)}# function to get Oct-Mar values from
obs<- obs.na %>% 
  rev %>% 
  na.locf %>% 
  rev %>% 
  `+`(na.locf(obs.na)) %>% 
  `/`(2) %>%  # fill NA with avg of adjacent values
  get.winter

# Now import TraCE-21k GCM data. Extract a time series for the grid cell covering the Salihli weather station. Add the model-output convective and large-scale precipitation variables to get total precipitation. Convert from m/s to mm/month. Subset time series to the calibration period (10 BP - AD 1940) and prediction period (10000 BP - 11 BP).

salihli.pt <- c(28.14, 38.48) %>% matrix(nrow = 1) %>% SpatialPoints  # create a point in Salihli to extract data from GCM

pc <- list.files('GCM Data/PRECC', full.names = T) %>%  # get a list of all GCM output files
  lapply(brick) %>%                                 # import GCM files as raster bricks
  lapply(., raster::extract,salihli.pt) %>%                  # extract series from the grid cell containing Salihli
  unlist                                            # combine into a single vector

pl <- list.files('GCM Data/PRECL', full.names = T) %>%  # get a list of all GCM output files
  lapply(brick) %>%                                 # import GCM files as raster bricks
  lapply(., raster::extract,salihli.pt) %>%                  # extract series from the grid cell containing Salihli
  unlist                                            # combine into a single vector

pt <- pc %>% add(pl) %>% multiply_by(60 * 60 * 24 * 30 * 1000)  # add precip components and convert from m/s to mm/month

cal <- pt %>% extract(122278:122877) %>% get.winter

pred <- pt %>% extract(2398:122397) %>% get.winter

pred.byfifty <- pred %>% seq_along %>% divide_by(300) %>% ceiling %>% split(pred,.)

calc.cdf <- function(x){
  pred <- x
  ct <- CDFt(obs, cal, pred)
  ct$DS
}
monthly.recon <- lapply(pred.byfifty, calc.cdf) %>% unlist
annual.recon <- monthly.recon %>% seq_along %>% divide_by(6) %>% ceiling %>% split(monthly.recon,.) %>%
  lapply(sum) %>% unlist %>% data.frame(date = seq(-10000,-1,1), p = ., color = cut(., c(0,200,300, 800)))

```

