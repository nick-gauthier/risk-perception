---
title: "risk-perception"
author: "Nick Gauthier"
date: "9/18/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lpSolve)

#library(zoo)
```

Start with a population of agents with the same subjective beliefs about drought risk.

```{r}
agents <- tibble(id = 1:5, 
                 alpha = 1.5,
                 beta = 1.5,
                 risk = alpha / (alpha + beta))
```

```{r}
agents
```


And payoffs for different crop types in different years.
```{r}
wheat_dry <- 0
wheat_wet <- 1.6
barley_dry <- 0.93
barley_wet <- 1.18

wheat_dry <- .2
wheat_wet <- .4
barley_dry <- 0.6
barley_wet <- .3
```

The expected yield is thus calculated as.
```{r}
expected_utility <- function(risk) {
  risk * (wheat_dry + barley_dry) + (1 - risk) * (wheat_wet + barley_wet) 
}
```

```{r}
expected_utility(0.2) # assuming a drought risk of 0.2
```

Given these payoffs, what's the point of indifference between the two crop types?

```{r, echo = FALSE}
plt_dat <- tibble(risk = seq(0, 1, .1),
       barley_exp = risk * barley_dry + (1 - risk) * barley_wet,
      wheat_exp = risk * wheat_dry + (1 - risk) * wheat_wet) %>%
  gather(type, utility, barley_exp:wheat_exp)
```

The pure maximin strategy is to plant barley:
```{r}
max(wheat_dry, barley_dry)
```


```{r, echo = FALSE}
indiff <- tibble(risk = (barley_wet - wheat_wet) / (wheat_dry - wheat_wet - barley_dry + barley_wet),
                 utility = risk * wheat_dry + (1 - risk) * wheat_wet)

plt_dat %>%
  ggplot(aes(risk, utility)) +
  geom_hline(yintercept = indiff$utility, linetype = 2)+
  geom_vline(xintercept = indiff$risk, linetype = 2) +
  geom_line(aes(color = type), size = 1.2) +
  geom_point(data = indiff, color = 'black', size = 3) +
  geom_text(data = indiff, label = '(0.3, 1.1)', nudge_x = 0.1, nudge_y = 0.1) +
  theme_classic()
```

The maximin strategy here is to plant barley all the time, but this entails a huge opportunity cost over planting wheat or a mix of the two

```{r, echo = FALSE}
plt_dat2 <- tibble(wheat_prop = seq(0, 1, .1),
       dry_exp = wheat_prop * wheat_dry + (1 - wheat_prop) * barley_dry,
      wet_exp = wheat_prop * wheat_wet + (1 - wheat_prop) * barley_wet) %>%
  gather(type, utility, dry_exp:wet_exp)
```

So the intersection point of the next plot is the mixed strategy equilbrium(indifference point) in a risk-free environment

```{r, echo = FALSE}
nash_eq <- tibble(wheat_prop = abs(barley_dry - barley_wet) / (abs(barley_dry - barley_wet) + abs(wheat_dry - wheat_wet)),
                  utility = wheat_prop * (wheat_dry + wheat_wet))

plt_dat2 %>%
  ggplot(aes(wheat_prop, utility)) +
  geom_hline(yintercept = nash_eq$utility, linetype = 2)+
  geom_vline(xintercept = nash_eq$wheat_prop, linetype = 2) +
  geom_line(aes(color = type), size = 1.2) +
  geom_point(data = nash_eq, color = 'black', size = 3) +
  geom_text(data = nash_eq, 
            label = paste0('(', nash_eq$wheat_prop, ', ', nash_eq$utility, ')'),
            nudge_x = 0.1, nudge_y = 0.05) +
  theme_classic()

```


when you sample from the expected value, use that to choose a strategy. but if you sample lots, use that to create a mixed streateg

And the subjective expected yields for the agents are thus.
```{r}
agents %>%
  mutate(risk = runif(n())) %>%
  mutate(yield_exp = expected_utility(risk),
         barley_exp = risk * barley_dry + (1 - risk) * barley_wet,
         wheat_exp = risk * wheat_dry + (1 - risk) * wheat_wet,
         favorite = case_when(barley_exp == wheat_exp ~ 'either',
                              barley_exp > wheat_exp ~ 'barley',
                              barley_exp < wheat_exp ~ 'wheat')) 
```


```{r}
calc_ratio <- function(risk) {
  pmax(0, (risk * barley_dry + (risk - 1) * barley_wet) / (risk * (barley_dry - wheat_dry) + wheat_wet * -1 * risk + wheat_wet + barley_wet * (risk - 1)))
}
```



Now create a population of agents with different subjective beliefs about the drought risk.
```{r}


test2 <- c((runif(25) < .2),(runif(25) < .5), runif(25) < .1)
tibble(time = 1:75,
       drought = test2) %>%
  mutate(period = round(time, -1)) %>%
  add_count(period) %>%
  filter(period >= 10) %>%
  group_by(period) %>%
  summarise(drought = sum(drought)) %>%
  ggplot(aes(period, drought)) +
  geom_col()
```






```{r}
learn <- function(agents, event) {
  agents %>%
    mutate(alpha = event + alpha,
           beta = beta + 1 - event,
           mu = alpha / (alpha + beta),
           estimate = map2_dbl(alpha, beta, ~rbeta(1, .x, .y)))
}

accumulate(test2, ~learn(.x, .y), .init = test) %>% bind_rows(.id = 'time') %>% qplot(as.numeric(time), estimate, data = ., geom = 'point')
```

```{r}
learn(test, TRUE)
```


The basic risk assessment algorithm. Let's look at the risk of a drought year being 0.2. In a wet year you get 3 wheat and 2 barley, and in a dry year you get 0 wheat and 1 barley. What does that look like?



maximax
```{r}
risk <- 0.9
wheat_exp <- wheat_wet * (1 - risk) + wheat_dry * risk
barley_exp <- barley_wet * (1 - risk) + barley_dry * risk
obj.fun <- c(wheat_exp, barley_exp)

constr=matrix(c(1,1,1,0,0,1, wheat_exp, barley_exp),ncol = 2, byrow = TRUE) #Loading the constraints
constr.dir=c("=",">=",">=", ">=")
constr.rhs=c(1,0,0, .5)

mod=lp("min",obj.fun,constr,constr.dir,constr.rhs) #Using lp() to solve our problem
mod$solution
```

```{r}
calc_payoff <- function(x, drought) {
  if (drought == 'TRUE') wheat_yield <- wheat_dry; barley_yield <- barley_dry
  if (drought == 'FALSE') wheat_yield <- wheat_wet; barley_yield <- barley_wet
  
  x %>%
    mutate(yield = wheat_yield * wheat_prop + barley_yield * (1 - wheat_prop))
}

update_prop <- function(x, aspiration) {
  x %>%
    mutate(new_prop = round(runif(n()), 2),
           wheat_prop = if_else(yield > aspiration, wheat_prop, new_prop)) %>%
    select(-new_prop)
}

test3 <- tibble(agent = 1:1000) %>%
  mutate(wheat_prop = round(runif(n()), 2)) %>%
  calc_payoff(drought = TRUE)
test3 %>% update_prop(aspiration = .6)

accumulate((runif(25) < .3), ~calc_payoff(.x, drought = .y) %>% update_prop(aspiration = .5), .init = test3) %>% bind_rows(.id = 'time') %>% ggplot(aes(as.numeric(time), yield, group = agent)) + geom_line(alpha = .2)

```

```{r}
library(ggridges)
accumulate((runif(25) < .2), ~calc_payoff(.x, drought = .y) %>% update_prop(aspiration = .6), .init = test3) %>% bind_rows(.id = 'time') %>% ggplot(aes(wheat_prop, y = as.numeric(time), group = as.numeric(time))) +
  geom_density_ridges() +
  theme_minimal()
```


So at between 3 in 10 and 4 in 10 risk of drought, a maximizer will switchfrom wheat to barley.


```{r}
test_dat <- expand_grid(wheat_prop = (0:10)/10,
       risk = seq(0, 1, 0.1)) %>%
  mutate(util_wet = (1 - risk) * (wheat_wet * wheat_prop + barley_wet * (1 - wheat_prop)),
         util_dry = risk * (wheat_dry * wheat_prop + barley_dry * (1 - wheat_prop)),
         util_wheat = wheat_prop * (wheat_wet * (1 - risk) + wheat_dry *  risk),
         util_barley = (1 - wheat_prop) * (barley_wet* (1 - risk) + barley_dry * risk),
         util_payoff = util_dry + util_wet)
```

```{r}
test_dat %>%
  select(-(util_wheat:util_barley)) %>%
  gather(type, util, c(util_dry, util_wet, util_payoff)) %>%
    ggplot(aes(wheat_prop, util, color = type)) + geom_line() + facet_wrap(~risk) + geom_hline(yintercept = .5, alpha = .3, linetype = 2) + geom_vline(xintercept = .14, alpha = 0.3,linetype = 2)
```
```{r}
test_dat %>%
  select(-(util_wheat:util_barley)) %>%
  mutate(util_min = pmin(util_wet, util_dry))%>%
    ggplot(aes(util_payoff, util_min)) + geom_line() + facet_wrap(~risk) + geom_hline(yintercept = .3, alpha = .3, linetype = 2)
```


```{r}
test_dat %>%
  group_by(risk) %>%
  filter(payoff == max(payoff)) %>%
  ggplot(aes(risk, wheat_prop)) + geom_point()

test_dat %>%
  select(-(util_dry:util_wet)) %>%
  gather(type, util, util_wheat:util_barley) %>%
    ggplot(aes(wheat_prop, util, color = type)) + geom_line() + facet_wrap(~risk) + geom_vline(xintercept = .14)
  


test_dat %>%
  ggplot(aes(wheat_prop, util_wet + util_dry)) + geom_point() + facet_wrap(~risk)

calc_prop <- function(risk) {
  pb <- barley_wet * (1 - risk) - barley_dry * risk
  pw <- wheat_wet * (1 - risk) - wheat_dry * risk

  pb / (pb + pw) 
}

plot(calc_prop((0:10)/10))
```



```{r}
tibble(x)
```


```{r}
calcNE <- function(risk){
  (118 - 25 * risk) / (278 - 185 * risk)
}


(barley_wet - .2 * (barley_dry + wheat_dry + wheat_wet + barley_wet)) / (barley_wet + wheat_wet)

calcNE(1)


plot(1.6 * (1:10)/10 + 1.18 * (10:1)/10)

util_wet <- wheat_wet * wheat_prop + barley_wet * (1 - wheat_prop)
util_dry <- wheat_dry * wheat_prop + barley_dry * (1 - wheat_prop)

tibble()

plot(seq(.1,1,.1) * (1 - seq(.1,1,.1)))

```


so we're imagining a yield of 1 for barley and 2 for wheat, with equal prportions of each. then in the next time step we'd revise the proportion to take away .25
```{r}
reallocate <- function(wheat_prop, risk) {
  wheat_prop + 1 * (1.18 * (1 - wheat_prop) - 1.6 * wheat_prop) * wheat_prop * (1 - wheat_prop)
}

accumulate(1:10, ~reallocate(.x), .init = .4) %>% plot

# so this works as long as you're between 0 and 1
```


```{r}

prior <- function(m,n){
a = n * m
b = n * (1 - m)
dom <- seq(0,1,0.005)
val <- dbeta(dom,a,b)
return(data.frame('x'=dom, 'y'=val))
}

prior(.5, 2) %>% plot
```

```{r}
likelihood <- function(N,Y){
a <- Y + 1
b <- N - Y + 1
dom <- seq(0,1,0.005)
val <- dbeta(dom,a,b)
return(data.frame('x'=dom, 'y'=val))
}

likelihood(1, 1)%>% plot
```

```{r}
posterior <- function(m,n,N,Y){
a <- Y + (n*m) -1
b <- N - Y + (n*(1-m)) - 1
dom <- seq(0,1,0.005)
val <- dbeta(dom,a,b)
return(data.frame('x'=dom, 'y'=val))
}


-1
1 - 0 - 1

dbeta(seq(0,1,0.005), -1, 0)
prior(.5, 2) %>% plot
posterior(.5, 3, 1, 1) %>% plot
```


so now we get the same yields, but the proportions are different
```{r}
(1 *  0.625 - 2 * .375) * .375 * .625
```

```{r}
1- .375
```


```{r}
-1 * 0.0625 * (1 - 0.0625)
```



```{r}
yield_max_barley <- 2500
yield_max_wheat <- 3500
kcal_barley <- 3000
kcal_wheat <- 3540

calc_yield <- function(rainfall, crop = 'wheat') {
  if (crop == 'wheat') {
    yield <- yield_max_wheat * kcal_wheat * pmax(0, 0.51 * log(rainfall) + 1.03)  # annual rainfall impact on yields
  }
  
  if(crop == 'barley') {
    yield <- yield_max_barley * kcal_barley * pmax(0, 0.48 * log(rainfall) + 1.51) 
  }
  
  return(yield)
}


tibble(rainfall = (0:200) / 100,
       barley = calc_yield(rainfall, 'barley'),
       wheat = calc_yield(rainfall, 'wheat')) %>%
  gather(crop, yield, barley:wheat) %>%
  ggplot(aes(rainfall, yield, color = crop)) + 
  geom_line() +
  geom_hline(yintercept = yield_max_wheat * kcal_wheat) +
  geom_hline(yintercept = yield_max_barley * kcal_barley) +
  geom_hline(yintercept = 1016525* 5, color ='red') +
  geom_vline(xintercept = 0.3)
```

How do we define the "drought year" cutoff? Below 300mm there isn't enough wheat growing in a hectare to feed a family of 5, which seems appropriate.
```{r}
test <- tibble(time = 1:100,
       rain = rnorm(100, mean = 1, sd = 1) %>% pmax(0),
       yield = calc_yield(rain))

ggplot(test, aes(time, yield)) + geom_point() + geom_hline(yintercept = 1016525)

test %>%
  mutate(drought = if_else(yield < 5e+6, TRUE, FALSE))%>%
  filter(drought == TRUE)
```


```{r}
# generate some forgetting curves
forgetting_curves <- tibble(x = c(.01, .1, 1, 0)) %>%
  mutate(memory = map(x, ~exp(-1 * . *1:50))) %>%
  unnest(cols= c(memory)) %>%
  group_by(x) %>%
  mutate(time = 1:n())

ggplot(forgetting_curves, aes(time, memory)) +
  geom_line(aes(color = as.factor(x)), size = 1.2) +
  labs(title = 'Forgetting curves', x = 'Years', y = 'Relative memory strength\n') +
  scale_color_viridis_d(name = 'Decay rate') +
  theme_classic()
```

```{r}
farm <- function(households){
  households %>%
    mutate(yield = climatic_yield, #* n_inhabitants ^ labor_elasticity,
           yield_memory = yield, #map2(yield_memory, yield, remember),
           harvest = land * yield * .5 - land * sowing_rate) #%>%  # *.5 is for fallow
  #select(-yield)
}


remember <- function(yield_memory, yield){
  # rnorm(1, yield, yield * 0.0333) %>%  #memory is fuzzy
  append(yield_memory[-length(yield_memory)], yield, after = 0) # remove the last entry in the vector and add new yield to the begining
}


#Agents use the peak-end rule when accessing memory.
peak_end <- function(x){
  map_dbl(x, ~mean(c(.x[1], min(.x))))
}

```




```{r}
obs.na <- read.csv('salihli_p.csv')[10:620, 5]  / 10  # raw data in mm*10. subset time series as water years (i.e. first observation is october, last is september)

get.winter <- function(x){seq(0, length(x) - 12, 12) %>%
    sapply(function(y) y + 1:6) %>%
    as.numeric %>% extract(x, .)}# function to get Oct-Mar values from
obs<- obs.na %>% 
  rev %>% 
  na.locf %>% 
  rev %>% 
  `+`(na.locf(obs.na)) %>% 
  `/`(2) %>%  # fill NA with avg of adjacent values
  get.winter

# Now import TraCE-21k GCM data. Extract a time series for the grid cell covering the Salihli weather station. Add the model-output convective and large-scale precipitation variables to get total precipitation. Convert from m/s to mm/month. Subset time series to the calibration period (10 BP - AD 1940) and prediction period (10000 BP - 11 BP).

salihli.pt <- c(28.14, 38.48) %>% matrix(nrow = 1) %>% SpatialPoints  # create a point in Salihli to extract data from GCM

pc <- list.files('GCM Data/PRECC', full.names = T) %>%  # get a list of all GCM output files
  lapply(brick) %>%                                 # import GCM files as raster bricks
  lapply(., raster::extract,salihli.pt) %>%                  # extract series from the grid cell containing Salihli
  unlist                                            # combine into a single vector

pl <- list.files('GCM Data/PRECL', full.names = T) %>%  # get a list of all GCM output files
  lapply(brick) %>%                                 # import GCM files as raster bricks
  lapply(., raster::extract,salihli.pt) %>%                  # extract series from the grid cell containing Salihli
  unlist                                            # combine into a single vector

pt <- pc %>% add(pl) %>% multiply_by(60 * 60 * 24 * 30 * 1000)  # add precip components and convert from m/s to mm/month

cal <- pt %>% extract(122278:122877) %>% get.winter

pred <- pt %>% extract(2398:122397) %>% get.winter

pred.byfifty <- pred %>% seq_along %>% divide_by(300) %>% ceiling %>% split(pred,.)

calc.cdf <- function(x){
  pred <- x
  ct <- CDFt(obs, cal, pred)
  ct$DS
}
monthly.recon <- lapply(pred.byfifty, calc.cdf) %>% unlist
annual.recon <- monthly.recon %>% seq_along %>% divide_by(6) %>% ceiling %>% split(monthly.recon,.) %>%
  lapply(sum) %>% unlist %>% data.frame(date = seq(-10000,-1,1), p = ., color = cut(., c(0,200,300, 800)))

```

